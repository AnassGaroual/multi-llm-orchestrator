/*
 * Copyright (c) 2025 Anass Garoual
 * Licensed under the MIT License.
 */
package com.multi.architecture;

import static org.assertj.core.api.Assertions.*;

import com.multi.domain.annotation.*;
import java.lang.reflect.*;
import java.util.*;
import java.util.stream.Collectors;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.reflections.Reflections;
import org.reflections.scanners.Scanners;

@DisplayName("DDD Architecture Tests - Java 25 Native")
class DddArchitectureTest {

  private static final String BASE_PACKAGE = "com.multi";
  private static final Reflections reflections =
      new Reflections(BASE_PACKAGE, Scanners.SubTypes, Scanners.TypesAnnotated);

  @Test
  void aggregates_should_be_in_domain_package() {
    var aggregates = reflections.getTypesAnnotatedWith(DomainAggregate.class);

    aggregates.forEach(
        aggregate ->
            assertThat(aggregate.getPackageName())
                .as("Aggregate %s must be in domain package", aggregate.getSimpleName())
                .contains(".domain."));
  }

  @Test
  void domain_should_not_depend_on_spring() {
    var domainClasses = getAllClassesInPackage("com.multi.domain");

    domainClasses.forEach(
        clazz -> {
          var imports = getClassDependencies(clazz);

          assertThat(imports)
              .as("Domain class %s must not depend on Spring", clazz.getSimpleName())
              .noneMatch(dep -> dep.startsWith("org.springframework"));
        });
  }

  @Test
  void domain_should_not_depend_on_adapters() {
    var domainClasses = getAllClassesInPackage("com.multi.domain");

    domainClasses.forEach(
        clazz -> {
          var imports = getClassDependencies(clazz);

          assertThat(imports)
              .as("Domain class %s must not depend on adapters", clazz.getSimpleName())
              .noneMatch(dep -> dep.contains(".adapters."));
        });
  }

  @Test
  void domain_should_not_depend_on_application() {
    var domainClasses = getAllClassesInPackage("com.multi.domain");

    domainClasses.forEach(
        clazz -> {
          var imports = getClassDependencies(clazz);

          assertThat(imports)
              .as("Domain class %s must not depend on application layer", clazz.getSimpleName())
              .noneMatch(dep -> dep.contains(".application."));
        });
  }

  @Test
  void value_objects_should_be_records() {
    var valueObjects = reflections.getTypesAnnotatedWith(DomainValueObject.class);

    valueObjects.forEach(
        vo -> {
          assertThat(vo.isRecord())
              .as("Value object %s must be a record", vo.getSimpleName())
              .isTrue();
        });
  }

  @Test
  void aggregates_should_not_depend_on_other_aggregates() {
    var aggregates = reflections.getTypesAnnotatedWith(DomainAggregate.class);

    aggregates.forEach(
        aggregate -> {
          var dependencies = getClassDependencies(aggregate);

          var otherAggregates =
              aggregates.stream()
                  .filter(other -> !other.equals(aggregate))
                  .map(Class::getName)
                  .collect(Collectors.toSet());

          var dependsOnAggregates = dependencies.stream().anyMatch(otherAggregates::contains);

          assertThat(dependsOnAggregates)
              .as("Aggregate %s should not depend on other aggregates", aggregate.getSimpleName())
              .isFalse();
        });
  }

  @Test
  void entities_should_have_private_final_fields() {
    var entities = reflections.getTypesAnnotatedWith(DomainEntity.class);

    entities.forEach(
        entity -> {
          var fields = entity.getDeclaredFields();

          for (Field field : fields) {
            // Skip synthetic fields (generated by compiler)
            if (field.isSynthetic()) continue;

            assertThat(Modifier.isPrivate(field.getModifiers()))
                .as(
                    "Field %s in entity %s must be private",
                    field.getName(), entity.getSimpleName())
                .isTrue();

            assertThat(Modifier.isFinal(field.getModifiers()))
                .as("Field %s in entity %s must be final", field.getName(), entity.getSimpleName())
                .isTrue();
          }
        });
  }

  @Test
  void aggregates_should_have_private_constructor() {
    var aggregates = reflections.getTypesAnnotatedWith(DomainAggregate.class);

    aggregates.forEach(
        aggregate -> {
          var constructors = aggregate.getDeclaredConstructors();

          var hasPrivateConstructor =
              Arrays.stream(constructors)
                  .anyMatch(
                      c ->
                          Modifier.isPrivate(c.getModifiers())
                              || !Modifier.isPublic(c.getModifiers()));

          assertThat(hasPrivateConstructor)
              .as(
                  "Aggregate %s should have private/package-private constructor",
                  aggregate.getSimpleName())
              .isTrue();
        });
  }

  @Test
  void factory_methods_should_be_static_and_public() {
    var allClasses = getAllClassesInPackage(BASE_PACKAGE);

    allClasses.forEach(
        clazz -> {
          var methods = clazz.getDeclaredMethods();

          for (Method method : methods) {
            if (method.isAnnotationPresent(FactoryMethod.class)) {
              assertThat(Modifier.isStatic(method.getModifiers()))
                  .as(
                      "Factory method %s in %s must be static",
                      method.getName(), clazz.getSimpleName())
                  .isTrue();

              assertThat(Modifier.isPublic(method.getModifiers()))
                  .as(
                      "Factory method %s in %s must be public",
                      method.getName(), clazz.getSimpleName())
                  .isTrue();
            }
          }
        });
  }

  // ===== HELPER METHODS =====

  private Set<Class<?>> getAllClassesInPackage(String packageName) {
    var reflections = new Reflections(packageName, Scanners.SubTypes);
    return reflections.getSubTypesOf(Object.class);
  }

  private Set<String> getClassDependencies(Class<?> clazz) {
    var dependencies = new HashSet<String>();

    // Fields
    for (Field field : clazz.getDeclaredFields()) {
      dependencies.add(field.getType().getName());

      // Generic types
      if (field.getGenericType() instanceof ParameterizedType pt) {
        for (Type arg : pt.getActualTypeArguments()) {
          if (arg instanceof Class<?> argClass) {
            dependencies.add(argClass.getName());
          }
        }
      }
    }

    // Methods
    for (Method method : clazz.getDeclaredMethods()) {
      dependencies.add(method.getReturnType().getName());

      for (Class<?> param : method.getParameterTypes()) {
        dependencies.add(param.getName());
      }
    }

    // Constructors
    for (Constructor<?> constructor : clazz.getDeclaredConstructors()) {
      for (Class<?> param : constructor.getParameterTypes()) {
        dependencies.add(param.getName());
      }
    }

    // Superclass
    if (clazz.getSuperclass() != null) {
      dependencies.add(clazz.getSuperclass().getName());
    }

    // Interfaces
    for (Class<?> iface : clazz.getInterfaces()) {
      dependencies.add(iface.getName());
    }

    return dependencies;
  }
}
